-- It spawns on smart terrains available for mutants if the current population of the smart is 0 or if no default ReSpawn Mutants are online on this smart.
-- ALL CREDIT GOES TO bvcx/xcvb for the original Night Mutants Mod
-- Another person I want to mention is Music_Hours for making Day Stalkers I've learned so much from them. Without them, this project will never exist.
-- Thanks to Hades@DK and his amazing RE:Spawn mutants. Without his work, this mod has no purpose

-- Configuration variables
-- If you don't use MCM then just modify the values here 

-- Define constants for magic numbers

local in_game_hour_multiplier = 600000

local MAX_SMART_ID = 65534

-- MCM values
local spawn_time_delay_min = 4    -- Minimum game minute delay for the spawn interval
local spawn_time_delay_max = 8    -- Maximum game minute delay for the spawn interval
local safe_radius = 60             -- No spawning within this player's radius
local enable_spawn_reserve = false -- toggles smart population reserving
local enable_ignore_smart_population = false -- toggles smart population ignored during spawning
local enable_all_maps_spawning = true -- toggle option to spawn specific mutants on all maps
local enable_boss_is_night_only = true
local day_start = 6                -- Time at which mutants start to spawn
local day_end = 20                 -- Deletes all mutants at this time (Skipping this time by sleeping will not delete mutants)
local active_boss_mutant = 0      -- Number of active boss mutant spawn squads
local spawn_reserve = 1            -- always reserve this number of slots on a smart for other scripts to spawn


local boss_spawn_probability = 30  -- Probability check for boss spawns to be successful
local predator_spawn_probability = 20
local wipe_mutants_on_level_change = true -- self explanatory
local enable_debug = false

local max_active_spawns = 0

local smart_terrain_exemptions = {}
-- Define a unified table for boss spawn statuses

local active_spawns = {}
local boss_mutant_squad_npcs = {}

-- Tables to store data
local squads_to_spawn = {}          -- List of squad sections to spawn
local available_smart_terrains = {} -- List of available smart terrains

local ray_table = {}
local ray_count_circle = 16
local ray_count_vertical = 8
local actor_in_safe_zone = true
local actor_is_indoors = true

-- time management
local xspawn_time = nil
local ctime_to_t = utils_data.CTime_to_table
local t_to_ctime = utils_data.CTime_from_table
local tmr

-- Define a timer variable and a delay duration
local monster_hit_timer = 0
local monster_hit_delay = 120000

local previous_actor_safe = false
local previous_attacker_name = ""
local number_of_spawn_attempts = 0
local plugin_file_name = "plugins\\rebound_encounters.ltx"
local difficulty_value = 0
local difficulty_level = ""
local squads_avaiable_this_rank = {}

local map_exemptions = 
{
    "l03u_agr_underground", "fake_start",  "jupiter_underground", "l08u_brainlab", "l04u_labx18", "l10u_bunker", "labx8", "l12u_control_monolith", "l13u_warlab", "l12u_sarcofag", "l08u_brainlab"
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- MCM

function fetch_values()
    spawn_time_delay_min = rebound_encounters_mcm.get_config("spawn_time_delay_min")
    spawn_time_delay_max = rebound_encounters_mcm.get_config("spawn_time_delay_max")
    safe_radius = rebound_encounters_mcm.get_config("safe_radius")
    day_start = rebound_encounters_mcm.get_config("day_start")
    day_end = rebound_encounters_mcm.get_config("day_end")
    boss_spawn_probability = rebound_encounters_mcm.get_config("boss_spawn_probability")
    predator_spawn_probability = rebound_encounters_mcm.get_config("predator_spawn_probability")
    wipe_mutants_on_level_change = rebound_encounters_mcm.get_config("wipe_mutants_on_level_change")
    enable_ignore_smart_population = rebound_encounters_mcm.get_config("enable_ignore_smart_population")
    enable_all_maps_spawning = rebound_encounters_mcm.get_config("enable_all_maps_spawning")
    enable_boss_is_night_only = rebound_encounters_mcm.get_config("enable_boss_is_night_only")
    enable_spawn_reserve = rebound_encounters_mcm.get_config("enable_spawn_reserve")
    enable_debug = rebound_encounters_mcm.get_config("enable_debug")

    if enable_spawn_reserve then
        spawn_reserve = 1
    else
        spawn_reserve = 0
    end

    difficulty_level = level.get_game_difficulty()
    
    local difficulty_value = nil

    if difficulty_level == 0 then -- Novice
        difficulty_value = tonumber(read_ltx_section(plugin_file_name,"spawn_difficulty","novice"))
    elseif difficulty_level == 1 then -- Stalker
        difficulty_value = tonumber(read_ltx_section(plugin_file_name,"spawn_difficulty","stalker"))
    elseif difficulty_level == 2 then -- Veteran
        difficulty_value = tonumber(read_ltx_section(plugin_file_name,"spawn_difficulty","veteran"))
    elseif difficulty_level == 3 then -- Master
        difficulty_value = tonumber(read_ltx_section(plugin_file_name,"spawn_difficulty","master"))
    end
        
    collect_squads_to_spawn()
end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- New function to collect squads to spawn
function collect_squads_to_spawn()
    squads_to_spawn = {} -- clear table first
    collect_squad_sections("respawn_" .. tostring(level.name())) -- retrieve level specific squads
    if enable_all_maps_spawning then
        collect_squad_sections("respawn_mutant") -- add mutants common to all levels
    end
end

-- update active boss mutant count from active_spawns
function count_active_boss_mutants()
    local count = 0
    for _, spawn in ipairs(active_spawns) do
        if spawn.is_boss_mutant then
            count = count + 1
        end
    end
    active_boss_mutant = count
end

-- Function to attempt spawning mutants
function try_to_spawn()
    fetch_values()
    local is_map_exempt = false
    local current_map_name = tostring(level.name())
    for index, map_name in pairs(map_exemptions) do         -- Check if the current map is meant to be exempt from spawns
        if map_name == current_map_name then
            is_map_exempt = true
            break
        end 
    end

    if is_map_exempt then
        pr("!This map is exempt from spawns")
        return
    end

    pr("--------------------------------------------------------")
    pr("ReSpawn Mutants Attempting to Spawn in %s","respawn_" .. tostring(level.name()))
    
    -- Collect and add section names
    collect_squads_to_spawn()  -- Call the new function
    -- Check if the table is empty
    if table_is_empty(squads_to_spawn) then
        pr("No squads to spawn. Ending script.")
        return  -- Ends the script execution
    end

    count_active_boss_mutants()
    
    if enable_debug then
        -- print what squads are available for spawning on this level
        pr("-- Mutants ready for spawning %s --", is_day() and "today" or "tonight")
        local squad_name = ""
        for i, squad in ipairs(squads_to_spawn) do
            squad_name = squad_name .. string.format("[%s] %s\t.  ", i, squad.sec)
            
            if i % 6 == 0 or i == #squads_to_spawn then
                local full_string = squad_name
                local to_remove = "respawn_"
                local result = string.gsub(full_string, to_remove, "")
                pr(result)
                squad_name = ""
            end
        end

        -- Print total number of available smart terrains for spawning
        pr("Total available smart terrains: %s", count_available_smart_terrains())
    end

    -- Start of more checks before spawning --
    -- adjust spawns depending on game difficulty
    local player_rank_value = get_rank_value(db.actor:character_rank())
    max_active_spawns = 0
    max_active_spawns = round(count_available_smart_terrains() * difficulty_value) -- spawn max based on smart terrain population on map
    if max_active_spawns < 4 then
        max_active_spawns = 4
    end
    max_active_spawns = max_active_spawns + player_rank_value
    number_of_spawn_attempts = max_active_spawns

    number_of_spawn_attempts = number_of_spawn_attempts

    local surge_active = surge_started()

    if number_of_spawn_attempts == 0 or surge_active then  -- If no attempts, exempt, or surge active
        pr("Spawn attempts: %s, Surge active: %s", number_of_spawn_attempts, surge_active)
        return
    else  -- Otherwise spawn for how many times "number_of_spawn_attempts" allows for this spawn cycle
        if number_of_spawn_attempts > 1 then
            pr("Spawning mutants: %s attempts", number_of_spawn_attempts)
        else
            pr("Spawning mutants: %s attempt", number_of_spawn_attempts)
        end

        for i = 1, number_of_spawn_attempts do
            -- Check maximum active spawns before each attempt
            local current_active_spawns = #active_spawns
            if current_active_spawns >= max_active_spawns then
                pr("Maximum active spawns reached: %s", count_available_smart_terrains())
            else
                spawn_mutants()  -- Call function to spawn mutants 
            end
        end
    end
    -- End of checks

    -- Print total count of active spawns after spawning
    if enable_debug then
        pr("-- Active Spawns Details --")
        local total_night_mutants = 0
        local total_predator_mutants = 0

        for _, spawn in ipairs(active_spawns) do
            local squad = alife_object(spawn.mutant_id)
            local exists = squad and "exists" or "does not exist"
            
            pr("Section: %s, Night Mutant: %s, Boss Mutant: %s, Predator Mutant: %s, Status: %s", 
                spawn.sec, tostring(spawn.is_night_mutant), tostring(spawn.is_boss_mutant), tostring(spawn.is_predator_mutant), exists)
            
            if squad then
                if spawn.is_night_mutant then
                    total_night_mutants = total_night_mutants + 1
                end
                
                if spawn.is_predator_mutant then
                    total_predator_mutants = total_predator_mutants + 1
                end
            end
        end

        pr("Total number of active spawns: %s, Night Mutants: %s, Predator Mutants: %s", #active_spawns, total_night_mutants, total_predator_mutants)
        pr("--------------------------------------------------------")
    end
end

-- test spawn mutant Function
-- Helper function to find a random boss mutant squad
function find_random_boss()
    local boss_squads = {}
    for _, squad in ipairs(squads_to_spawn) do
        if squad.is_boss_mutant then
            table.insert(boss_squads, squad)
        end
    end
    return #boss_squads > 0 and boss_squads[math.random(1, #boss_squads)] or nil
end

-- Helper function to find a random non-boss mutant squad
function find_random_non_boss()
    local non_boss_squads = {}
    for _, squad in ipairs(squads_to_spawn) do
        if not squad.is_boss_mutant then
            table.insert(non_boss_squads, squad)
        end
    end
    return #non_boss_squads > 0 and non_boss_squads[math.random(1, #non_boss_squads)] or nil
end

-- Main spawn mutants function
function spawn_mutants()
    local has_spawned = false

    -- Randomly select a boss and a non-boss squad
    local boss_random_squad = find_random_boss()
    local random_squad = find_random_non_boss()
    local chosen_squad = nil

    -- Loop through available smart terrains to find a suitable one
    for _, t in pairs(available_smart_terrains) do
        for i = 1, #t do
            local selected_smart_id = t[i]
            local simboard_t = SIMBOARD.smarts[selected_smart_id]
            local smart = simboard_t and simboard_t.smrt

            if smart then
                local smart_cur_pop = simboard_t.population
                local smart_max_pop = smart.max_population - spawn_reserve

                -- Check if a spawn already exists in the given smart
                local spawn_exists = false
                for _, spawn in ipairs(active_spawns) do
                    if spawn.smart_id == selected_smart_id then
                        spawn_exists = true
                        break
                    end
                end

                -- Check population limits or override if enabled
                local allow_pop_spawn = smart_cur_pop < smart_max_pop
                if enable_ignore_smart_population then
                    allow_pop_spawn = true
                end

                -- If conditions are met, proceed to attempt spawning
                if not has_spawned and allow_pop_spawn and not spawn_exists and se_obj_outside_spawn_radius(smart, safe_radius) then
                    local spawn_boss_chance = math.random(1, 100)
                    local squad_sec = nil

                    -- Decide if we should spawn a boss mutant
                    if active_boss_mutant == 0 and boss_random_squad and (spawn_boss_chance <= boss_spawn_probability) then
                        chosen_squad = boss_random_squad
                        squad_sec = boss_random_squad.sec
                    else
                        chosen_squad = random_squad
                        squad_sec = random_squad and random_squad.sec
                    end

                    -- Attempt to create the squad in the selected smart
                    local squad = squad_sec and SIMBOARD:create_squad(smart, squad_sec)
                    
                    if squad then
                        -- Handle predator flag for the squad
                        if chosen_squad.is_predator_mutant or (math.random(1, 100) <= predator_spawn_probability) then
                            chosen_squad.is_predator_mutant = true
                        end

                        -- Add the new spawn to active_spawns
                        table.insert(active_spawns, { 
                            smart_id = selected_smart_id, 
                            mutant_id = squad.id, 
                            level_name = level.name(), 
                            sec = squad_sec,
                            is_night_mutant = chosen_squad.is_night_mutant, 
                            is_boss_mutant = chosen_squad.is_boss_mutant,
                            is_predator_mutant = chosen_squad.is_predator_mutant
                        })

                        -- Update boss count and send message if a boss spawned
                        if chosen_squad.is_boss_mutant then
                            active_boss_mutant = 1

                            local location_description = dynamic_news_helper.GetPointDescription(squad)
                            local phrase_keys = get_phrase_keys("rebound_encounters_boss_spawn_warnings")
                            local translated_text = ""
                            -- Select a random key and retrieve its translation
                            if #phrase_keys > 0 then
                                local random_key = phrase_keys[math.random(#phrase_keys)]
                                translated_text = game.translate_string(random_key)
                            end
                            if db.actor then
                                local boss_name = squad:name()
                                boss_name = boss_name:match("respawn_(%a+)")
                                boss_name = "respawn_mutant_" .. boss_name
                                boss_name = game.translate_string(boss_name)
                                local message = string.format(translated_text, boss_name, location_description)
                                news_manager.send_tip(db.actor, message, nil, nil, 30000)
                            else
                                pr("Warning: Unable to send message, db.actor is nil")
                            end
                        else
                            local actor_rank_value = get_rank_value(db.actor:character_rank())
                            add_squad_members(squad, actor_rank_value)
                        end

                        -- Set has_spawned to true and exit loops to stop further spawning attempts
                        has_spawned = true
                        break
                    end
                end
            end
        end
        if has_spawned then break end  -- Exit the main loop if a spawn occurred
    end
end

function add_squad_members(squad, number_to_add)
    local half_value = number_to_add / 2
    local whole_value = math.floor(half_value)
    local max_squad_count = math.random(1, whole_value)

    while squad:npc_count() < max_squad_count do

        local commander = alife_object(squad:commander_id())
        local pos = commander.position
        local lvid = commander.m_level_vertex_id
        local gvid = commander.m_game_vertex_id

        local squad_smart = squad.smart_id and SIMBOARD.smarts[squad.smart_id].smrt
        if not squad_smart then return end

        local random_spawn = ini_sys:r_string_ex(squad:section_name(), "npc_random")
        if not random_spawn then return end

        random_spawn = parse_names(random_spawn)
        local random_sec = random_spawn[math.random(1, #random_spawn)]

        local new_member_id = squad:add_squad_member(random_sec, pos, lvid, gvid)
        local se_obj = new_member_id and alife_object(new_member_id)
        if se_obj then
            squad_smart:register_npc(se_obj)
            SIMBOARD:setup_squad_and_group(se_obj)
        end

        -- Update the squad
        squad:update()
    end
end

function delete_mutants()
    for idx = #active_spawns, 1, -1 do
        local spawn = active_spawns[idx]
        local squad = alife_object(spawn.mutant_id)

        if squad then
            if squad.remove_squad and squad.get_script_target then
                pr("squad id: %s marked for deletion", spawn.mutant_id)
                
                -- Release the squad by mutant_id
                alife_release(squad)
                pr("RE:Bound squad id: %s released", spawn.mutant_id)

                -- Decrement active_boss_mutant if a boss mutant is deleted
                if spawn.is_boss_mutant then
                    active_boss_mutant = 0
                end

                -- Remove the entry from active_spawns
                table.remove(active_spawns, idx)
            else
                pr("Warning: squad id %s is not a valid squad object", spawn.mutant_id)
            end
        else
            pr("Warning: squad id %s does not exist", spawn.mutant_id)
        end
    end

    -- Confirm active_spawns table status after cleanup
    pr(string.format("Active spawns remaining: %d", #active_spawns))
end



-- Callback function when a server entity unregisters
function server_entity_on_unregister(obj)
    for idx, spawn in ipairs(active_spawns) do
        if obj.id == spawn.mutant_id then
            pr("RE:Bound removing squad_id: %s from table", spawn.mutant_id)
            
            -- Decrement active_boss_mutant if a boss mutant is unregistered
            if spawn.is_boss_mutant then
                active_boss_mutant = 0
                
                -- Send a message to the player
                if db.actor then
                    local phrase_keys = get_phrase_keys("rebound_encounters_boss_spawn_eliminated")
                    local translated_text = ""
                    -- Select a random key and retrieve its translation
                    if #phrase_keys > 0 then
                        local random_key = phrase_keys[math.random(#phrase_keys)]
                        translated_text = game.translate_string(random_key)
                    end
                    
                    -- Remove "respawn_" prefix and numbers at the end, then capitalize the first letter
                    local boss_name = obj:name()
                    boss_name = boss_name:match("respawn_(%a+)")
                    boss_name = "respawn_mutant_" .. boss_name
                    boss_name = game.translate_string(boss_name)
                    
                    -- Get the location description using dynamic_news_helper
                    local location_description = dynamic_news_helper.GetPointDescription(obj)
                    
                    -- Format the message
                    local message = string.format(translated_text, boss_name, location_description)
                    
                    news_manager.send_tip(db.actor, message, nil, nil, 30000)
                else
                    pr("Warning: Unable to send message, db.actor is nil")
                end
            end
            
            table.remove(active_spawns, idx)
        end
    end
end

-- Save smart terrains that can spawn ReSpawn Mutants
function save_respawn_smarts()
    available_smart_terrains = {}
    for i = 1, MAX_SMART_ID do
        local smart = alife_object(i)
        if smart and (smart:clsid() == clsid.smart_terrain) then
            local smart_name = smart:name() or smart:section_name() or "<empty>"
            local smart_level_name = get_se_obj_level_name(smart)
            
            local smart_is_exempt = false
            for index, exempt_smart in pairs(smart_terrain_exemptions) do
                if exempt_smart == tostring(smart_name) then
                    smart_is_exempt = true
                    break
                end 
            end

            local smart_is_on_current_level = false
            if tostring(smart_level_name) == tostring(level.name()) then
                smart_is_on_current_level = true
            end

            if (smart_is_exempt == false) and smart_is_on_current_level then
                available_smart_terrains[smart_level_name] = available_smart_terrains[smart_level_name] or {}
                table.insert(available_smart_terrains[smart_level_name], smart.id)
            end
        end
    end
end

-- Collect and add section names based on current map and player rank
function collect_squad_sections(squad_tag)
    -- populate table of squads that should be available at current rank first
    local ini_config = ini_file(plugin_file_name)
    squads_avaiable_this_rank = {}
    local player_rank_value = get_rank_value(db.actor:character_rank())
    
    -- add weak mutants first
    local line_count = ini_config:line_count("weak_mutants")
    for i = 0, line_count - 1 do
        local result, id, value = ini_config:r_line_ex("weak_mutants", i, "", "")
        if id then
            table.insert(squads_avaiable_this_rank, id)
        end
    end

    -- add boss mutants
    line_count = ini_config:line_count("boss_mutants")
    for i = 0, line_count - 1 do
    local result, id, value = ini_config:r_line_ex("boss_mutants", i, "", "")
    if id then
        table.insert(squads_avaiable_this_rank, id)
    end
    end

    -- add normal mutants if rank value is less than 5
    if (player_rank_value > 2) and (player_rank_value < 5) then
        line_count = ini_config:line_count("normal_mutants")
        for i = 0, line_count - 1 do
            local result, id, value = ini_config:r_line_ex("normal_mutants", i, "", "")
            if id then
                table.insert(squads_avaiable_this_rank, id)
            end
        end
    end
    -- add strong mutants if rank value is greater or equal to 5
    if player_rank_value >= 5 then
        line_count = ini_config:line_count("strong_mutants")
        for i = 0, line_count - 1 do
            local result, id, value = ini_config:r_line_ex("strong_mutants", i, "", "")
            if id then
                table.insert(squads_avaiable_this_rank, id)
            end
        end
    end

    ini_sys:section_for_each(function(sec)
        local respawn_mutant = ini_sys:r_bool_ex(sec, squad_tag)
        local is_night_mutant = ini_sys:r_bool_ex(sec, "is_night_mutant") or false
        local is_boss_mutant = ini_sys:r_bool_ex(sec, "is_boss_mutant") or false
        local is_predator_mutant = ini_sys:r_bool_ex(sec, "is_predator_mutant") or false
        
        if is_day() then
            if respawn_mutant and not is_night_mutant and not (is_boss_mutant and enable_boss_is_night_only) then
                local existing_section = nil
                for _, squad in ipairs(squads_to_spawn) do
                    if squad.sec == sec then
                        existing_section = squad
                        break
                    end
                end
                
                if not existing_section then
                    -- Check if the section is in the list of squads available at this rank
                    local squad_permitted_this_rank = false
                    for _, squad in ipairs(squads_avaiable_this_rank) do
                        if squad == sec then
                            squad_permitted_this_rank = true
                            break
                        end
                    end
                    if squad_permitted_this_rank then
                        table.insert(squads_to_spawn, {
                            sec = sec, 
                            is_night_mutant = is_night_mutant or false, 
                            is_boss_mutant = is_boss_mutant or false,
                            is_predator_mutant = is_predator_mutant or false  -- Include is_predator_mutant
                        })
                    end
                end
            end
        else
            if respawn_mutant and (is_night_mutant or (is_boss_mutant and enable_boss_is_night_only)) then
                local existing_section = nil
                for _, squad in ipairs(squads_to_spawn) do
                    if squad.sec == sec then
                        existing_section = squad
                        break
                    end
                end
                
                if not existing_section then
                    -- Check if the section is in the list of squads available at this rank
                    local squad_permitted_this_rank = false
                    for _, squad in ipairs(squads_avaiable_this_rank) do
                        if squad == sec then
                            squad_permitted_this_rank = true
                            break
                        end
                    end
                    if squad_permitted_this_rank then
                        table.insert(squads_to_spawn, {
                            sec = sec, 
                            is_night_mutant = is_night_mutant or false, 
                            is_boss_mutant = is_boss_mutant or false,
                            is_predator_mutant = is_predator_mutant or false  -- Include is_predator_mutant
                        })
                    end
                end
            end
        end
    end)
end

function table_is_empty(t)
    return next(t) == nil
end

-- Check if an object is outside the spawn radius
function se_obj_outside_spawn_radius(se_obj, radius)
    if not se_obj then
        return false
    end

    -- Check if the object is on the same level as the player
    local actor = alife():actor()
    if not actor then
        return false
    end

    local on_same_level = simulation_objects.is_on_the_same_level(actor, se_obj)
    if not on_same_level then
        return true
    end

    -- Calculate the distance between the player's position and the object's position
    local ac_pos = db.actor:position()
    local se_obj_pos = se_obj.position
    local outside_radius = ac_pos:distance_to_xz(se_obj_pos) > radius

    return outside_radius
end

-- Check if it's currently day time
function is_day()
    local cur_hour = level.get_time_hours() + level.get_time_minutes() / 60
    if day_start < day_end then
        return (cur_hour >= day_start) and (cur_hour < day_end)
    else
        return (cur_hour >= day_start) or (cur_hour < day_end)
    end
end

-- Get the level name of a smart terrain object
function get_se_obj_level_name(se_obj)
    local vertex = game_graph():vertex(se_obj.m_game_vertex_id)
    if not vertex then
        return "<unknown>"
    end

    local target_level_id = vertex:level_id()
    local target_level_name = alife():level_name(target_level_id)
    return target_level_name
end

-- Print debug messages if debugging is enabled
function pr(...)
    if not enable_debug then return end
    printf(...)
end

-- Save the state of the script
function save_state(m_data)
    m_data.active_spawns = active_spawns
    m_data.smart_terrain_exemptions = smart_terrain_exemptions
    m_data.boss_mutant_squad_npcs = boss_mutant_squad_npcs
    m_data.squads_to_spawn = squads_to_spawn
    m_data.available_smart_terrains = available_smart_terrains
    m_data.xspawn_time = xspawn_time
    m_data.active_boss_mutant = active_boss_mutant
end

-- Load the state of the script
function load_state(m_data)
    active_spawns = m_data.active_spawns or {}
    smart_terrain_exemptions = m_data.smart_terrain_exemptions or {}
    boss_mutant_squad_npcs = m_data.boss_mutant_squad_npcs or {}
    squads_to_spawn = m_data.squads_to_spawn or {}
    available_smart_terrains = m_data.available_smart_terrains or {}
    xspawn_time = m_data.xspawn_time
    active_boss_mutant = m_data.active_boss_mutant or 0
end

-- Runs when changing level
function on_before_level_changing()
    if wipe_mutants_on_level_change then
        delete_mutants()
        pr("Level is changing, wiping ReSpawn Mutants")
    end
end

-- Check to see if an emission or psy storm is active
function surge_started()
    return surge_manager.is_loaded() and surge_manager.is_started() or psi_storm_manager.is_loaded() and psi_storm_manager.is_started()
end

-- Function to load smart terrain exemptions from rebound_encounters.ltx
function load_smart_terrain_exemptions()
    local ini_config = ini_file(plugin_file_name)
    
    -- Clear the existing smart_terrain_exemptions table
    smart_terrain_exemptions = {}

    -- Read the smart_terrain_exemptions section
    local line_count = ini_config:line_count("smart_terrain_exemptions")
    for i = 0, line_count - 1 do
        local result, id, value = ini_config:r_line_ex("smart_terrain_exemptions", i, "", "")
        if id then
            table.insert(smart_terrain_exemptions, id)
        end
    end
end

function check_actor_in_safe_zone()
    local id = smart_terrain.nearest_to_actor_smart.id
    local smart = id and alife_object(id)
    local dist = smart_terrain.nearest_to_actor_smart.dist

    local is_exempt = false
    if smart then  -- Ensure smart is not nil
        for _, exempt_name in ipairs(smart_terrain_exemptions) do
            if smart:name() == exempt_name then
                is_exempt = true
                break
            end
        end

        if is_exempt and dist <= 60 then
            pr("id: [%s] name: [%s] dist: [%s] || safe: [true]", id, smart:name(), round_idp(dist, 2))
            return true
        end
    end

    pr("Actor is not in a safe zone")
    return false  -- Actor is not in a safe zone
end

-- requires demonized_geometry_ray.script to work
function is_actor_safe()

    local surge_state = GetEvent("surge", "state")
	local psi_storm_state = GetEvent("psi_storm", "state")

    if (surge_state) or (psi_storm_state) then
        actor_is_indoors = true
        return
    end

    local pos = db.actor:position()
    if IsMoveState("mcCrouch") and IsMoveState("mcAccel") then -- Prone
        pos.y = pos.y + 0.25
    elseif IsMoveState("mcCrouch") then
        pos.y = pos.y + 0.5
    else
        pos.y = pos.y + 0.75
    end

    local total_points = 0
    local ray_count = size_table(ray_table)  -- Use the size of ray_table
    local ray_range = 8   -- Range of each ray
    local cover_prcnt_needed = 0.85  -- Percentage of cover needed to be considered safe
    local cover_prcnt_threshold = 0.70

    for i = 1, ray_count do
        local ray_args = {
            ray_range = ray_range,
            contact_range = ray_range - 0.01,
            flags = (1 + 2 + 4 + 8),  -- Adjust flags as needed
            ignore_object = db.actor
        }

        -- Use the ray direction from ray_table
        local ray_dir = ray_table[i]
        local ray = demonized_geometry_ray.geometry_ray(ray_args)
        local result = ray:get(pos, ray_dir)

        while result.in_contact and result.result.material_name do
            local name = result.result.material_name
            if not (string.find(name, "bush") or string.find(name, "water")) then
                break -- break out of the loop if contact is not a bush
            end
            ray_args.ray_range = ray_args.ray_range - result.distance
            ray_args.contact_range = ray_args.contact_range - result.distance
            ray = demonized_geometry_ray.geometry_ray(ray_args)
            local new_pos = vector():set(result.position):add(vector():set(ray_dir):mul(0.01))
            result = ray:get(new_pos, ray_dir)
        end

        if result.in_contact then
            total_points = total_points + 1  -- Increment points for each contact
        end
    end

    -- Determine if the actor is safe based on total points
    local cover_percentage = (total_points / ray_count) * 100
    local current_cover_prcnt = total_points / ray_count
    --local actor_is_safe = current_cover_prcnt > cover_prcnt_needed and not (current_cover_prcnt < cover_prcnt_threshold)
    local actor_is_safe = true
    if current_cover_prcnt >= cover_prcnt_needed then
        actor_is_safe = true
    else
        actor_is_safe = true
        if current_cover_prcnt <= cover_prcnt_threshold then
            actor_is_safe = false
        end
    end
    -- Call toggle_predator_targeting only if the state has changed
    if previous_actor_safe ~= actor_is_safe then
        actor_is_indoors = actor_is_safe
        toggle_predator_targeting()
        previous_actor_safe = actor_is_safe  -- Update the previous state
        pr("Cover percentage: %s : Indoor: %s", cover_percentage, actor_is_indoors)
        if actor_is_safe then
            actor_menu.set_msg(1, game.translate_string("st_safe_area"), 2)
        end
    end
end


function notify_boss_mutant_status()
    pr("--Checking Boss Mutant Status--")
    for _, spawn in ipairs(active_spawns) do
        if spawn.is_boss_mutant then
            local squad = alife_object(spawn.mutant_id)
            if squad then
                local phrase_keys = get_phrase_keys("rebound_encounters_boss_spawn_still_active")
                local translated_text = ""
                -- Select a random key and retrieve its translation
                if #phrase_keys > 0 then
                    local random_key = phrase_keys[math.random(#phrase_keys)]
                    translated_text = game.translate_string(random_key)
                end

                local active_message = translated_text
                
                local boss_name = squad:name()
                boss_name = boss_name:match("respawn_(%a+)")
                boss_name = "respawn_mutant_" .. boss_name
                boss_name = game.translate_string(boss_name)
                
                -- Get the location description using dynamic_news_helper
                local location_description = dynamic_news_helper.GetPointDescription(squad)
                
                -- Format the message
                local message = string.format(active_message, boss_name, location_description)
                
                -- Send the message to the player
                if db.actor then
                    news_manager.send_tip(db.actor, message, nil, nil, 30000)
                else
                    pr("Warning: Unable to send message, db.actor is nil")
                end
            end
        end
    end
end

function check_if_in_safe_zone()
    actor_in_safe_zone = check_actor_in_safe_zone()
    toggle_predator_targeting()
end

function toggle_predator_targeting()
    for _, spawn in ipairs(active_spawns) do
        if spawn.is_predator_mutant then
            local se = alife_object(spawn.mutant_id)
            if se and (se:section_name() == spawn.sec) then
                if not actor_in_safe_zone and not actor_is_indoors then -- actor is not safe
                    se.scripted_target = "actor"
                    se.rush_to_target = true
                    pr("Spawn ID [%s] Target Status: %s, Rushing: %s", spawn.mutant_id, se.scripted_target, se.rush_to_target)
                else                                                    -- actor is safe
                    for _, smart_list in pairs(available_smart_terrains) do
                        if smart_list and #smart_list > 0 then
                            local random_smart_id = smart_list[math.random(1, #smart_list)]
                            local random_smart = alife_object(random_smart_id)
                            if random_smart and random_smart:clsid() == clsid.smart_terrain then
                                local smart_name = random_smart:name()
                                -- Set the smart ID and name as target
                                se.scripted_target = smart_name
                                se.rush_to_target = true
                                pr("Spawn ID [%s] Target Status: %s, Rushing: %s", spawn.mutant_id, se.scripted_target, se.rush_to_target)
                                break  -- Exit the loop once a valid smart terrain is found
                            end
                        end
                    end

                end
            end
        end    
    end
    pr("! Adjusted predator activity. Safe Zone: %s || Indoors: %s", actor_in_safe_zone, actor_is_indoors)
end
-- Function to stop targeting when the player opens the sleep menu
function actor_sleeping(hud_name)
    if hud_name == "UISleep" then
        pr("Stopping mutant attacks due to actor initiating sleep")
        
        for _, spawn in pairs(active_spawns) do
            local se = alife_object(spawn.mutant_id)
            if se and (se:section_name() == spawn.sec) then
                -- Disable targeting for all mutants
                se.scripted_target = nil
                se.rush_to_target = false
            end
        end
    end
end

-- New function to assign random smart terrain targets to non-predator mutants
function assign_random_smart_target()
    ResetTimeEvent("cycle", "assign_smart_target", math.random(5, 10) * 60)

    for _, spawn in pairs(active_spawns) do
        local se = alife_object(spawn.mutant_id)
        
        -- Check if the mutant is not a predator before assigning a target
        if se and not spawn.is_predator_mutant then
            -- Assign a random smart terrain as target for non-predator mutants
            for _, smart_list in pairs(available_smart_terrains) do
                if smart_list and #smart_list > 0 then
                    local random_smart_id = smart_list[math.random(1, #smart_list)]
                    local random_smart = alife_object(random_smart_id)
                    if random_smart and random_smart:clsid() == clsid.smart_terrain then
                        local smart_name = random_smart:name()

                        -- Set the smart ID and name as target
                        se.scripted_target = smart_name
                        se.rush_to_target = true
                        pr("Non-predator mutant [%s] assigned to smart terrain [%s]", se:section_name(), smart_name)
                        break  -- Exit the loop once a valid smart terrain is found
                    end
                end
            end
        end
    end
end
    
function update_mutant_spawn_status()
    -- Reset the time event to run again in 60 seconds
    ResetTimeEvent("cycle", "update_mutant_spawn_status", 120)

    check_if_in_safe_zone()
    store_boss_mutant_npcs()
    notify_boss_mutant_status()
end

-- New function to send a random rumor and squad section to the actor
function send_random_rumor()
    local phrase_keys = get_phrase_keys("rebound_encounters_level_rumors")

    -- Select a random key and retrieve its translation
    -- Check if there are squads to spawn
    if not table_is_empty(squads_to_spawn) and (#phrase_keys > 0) then
        local random_key = phrase_keys[math.random(#phrase_keys)]
        local random_rumor = game.translate_string(random_key)  -- Pick a random rumor
        local random_squad = squads_to_spawn[math.random(1, #squads_to_spawn)].sec  -- Pick a random squad section


        local random_squad = string.gsub(random_squad, "respawn_", "respawn_mutant_")
        local translated_squad = game.translate_string(random_squad)

        -- Concatenate the rumor and edited squad section
        local message = string.format(random_rumor, translated_squad)

        -- Send the message to the actor
        if db.actor then
            news_manager.send_tip(db.actor, message, nil, nil, 30000)
        else
            pr("Warning: Unable to send message, db.actor is nil")
        end
    end
end

function count_available_smart_terrains()
    local total_count = 0
    for _, smart_list in pairs(available_smart_terrains) do
        total_count = total_count + #smart_list  -- Add the length of each smart terrain list
    end
    return total_count
end
-- 
function actor_on_first_update()
    load_smart_terrain_exemptions()
    save_respawn_smarts()

    init_ray_table()

    CreateTimeEvent("cycle", "update_mutant_spawn_status", 60, update_mutant_spawn_status)
    CreateTimeEvent("cycle", "assign_smart_target", 60, assign_random_smart_target)
    
    if not active_spawns[1] or #active_spawns == 0 then
        shuffle_smart_ids() -- reshuffle smart id order
        try_to_spawn()
    end
end

-- Function to check for active boss squads and store their NPC IDs
function store_boss_mutant_npcs()
    -- Clear the previous entries in the table
    boss_mutant_squad_npcs = {}

    for _, spawn in ipairs(active_spawns) do
        if spawn.is_boss_mutant then
            local squad = alife_object(spawn.mutant_id)
            if squad and squad.commander_id then
                for m in squad:squad_members() do
                    -- Get the server object for the NPC
                    local se_npc = alife_object(m.id)
                    if se_npc then
                        boss_mutant_squad_npcs[se_npc.id] = true  -- Store NPC ID
                    end
                end
            end
        end
    end
end

function monster_on_death_callback(npc, who)
	local id = npc:id()
    local killer = who:name()
    local reward_money = math.random(5000, 10000)
    local message = "You received " .. reward_money .. " for killing the boss mutant."
    -- Check if the id is in the boss_mutant_squad_npcs table and if the killer is the actor
    for stored_id in pairs(boss_mutant_squad_npcs) do
        if stored_id == id and killer == "actor" then
            db.actor:give_money(reward_money)
            news_manager.send_tip(db.actor, message, nil, nil, 3000)
            break  -- Exit the loop once the item is created
        end
    end
end

function monster_on_loot_init(victim, loot_table)

    loot_table = {}
    --if string.find(victim:section(), "mutagen") then
        --t["af_fireball"] = { count = 1 }
        --t["money_1000_5000"] = { count = 10 }
    --end
end

function actor_on_update()
    -- time check for spawning interval
    local tg = time_global()
    if (tmr and tg < tmr) then return end  -- If the timer hasn't expired, return
    if is_day() then
        tmr = tg + (math.random(spawn_time_delay_min, spawn_time_delay_max) * in_game_hour_multiplier) -- 1 in-game hour interval per value in MCM
    else
        tmr = tg + (math.random(spawn_time_delay_min, spawn_time_delay_max) * (in_game_hour_multiplier/2)) -- makes night mutants spawn half the interval compared to day time
    end

    local cur_time = game.get_game_time()
    if not xspawn_time then
        xspawn_time = ctime_to_t(cur_time)  -- Initialize spawn time if not set
    end

    if cur_time:diffSec(t_to_ctime(xspawn_time)) > (1 * 120) then
        xspawn_time = ctime_to_t(cur_time)  -- Reset spawn time
        shuffle_smart_ids()
        try_to_spawn()
        if math.random() <= 0.6 then
            send_random_rumor()
        end
        
    end

    
end

function init_ray_table()
    -- Build a table of ray directions
    ray_table = {}
    local counter = 1
    for i = 1, ray_count_circle do
        for ii = 0, ray_count_vertical - 1 do
            if not (ii == ray_count_vertical - 1 and i % 3 ~= 0) and not (ii == ray_count_vertical - 2 and i % 2 == 0) then -- reduce rays at top angles
                local ray_dir = vector():set(0, 0, 1)
                local angle = (ii / (ray_count_vertical - 1)) * 82 -- 82 degrees to not shoot many rays straight up in the same direction

                ray_dir.y = math.sin(angle * 0.017453292519943295769236907684886)
                ray_dir.z = math.cos(angle * 0.017453292519943295769236907684886)

                local rot_angle = (i / ray_count_circle) * 360
                ray_dir = vector_rotate_y(ray_dir, rot_angle):normalize()

                ray_table[counter] = vector():set(ray_dir)
                counter = counter + 1
            end
        end
    end
end


function monster_on_hit_callback(npc, amount, local_direction, who, bone_index)
    -- Check if the timer has expired
    local current_time = time_global() -- Get the current game time
    if (current_time - monster_hit_timer) < monster_hit_delay then
        return -- Exit the function if the delay has not expired
    end

    -- Update the timer to the current time
    monster_hit_timer = current_time

    if math.random() <= 0.3 then
        -- Check if the NPC and the attacker are valid
        if not npc or not who then return end
        local squad_sec_to_compare = ""
        
        -- Get the names of the NPC and the attacker
        local npc_section = npc:section()
        if not npc_section then return end -- Ensure npc:section() is valid

        local npc_name = npc_section:match("^[^_]+") or "Unknown NPC" -- Extracts the part before the underscore
        local attacker_name = IsStalker(who) and (who:character_name() or "an unknown stalker") or "an unknown stalker"

        if attacker_name == previous_attacker_name then
            return
        else
            previous_attacker_name = attacker_name
        end

        -- Check if mutant is on squads_to_spawn list
        local is_mutant_in_spawn_pool = false
        for _, squad in ipairs(squads_to_spawn) do
            squad_sec_to_compare = squad_sec_to_compare .. squad.sec .. " - "
            if squad.sec and string.find(squad.sec, npc_name) then
                is_mutant_in_spawn_pool = true
                break
            end
        end

        if npc_name ~= "Unknown NPC" then
            npc_name = game.translate_string("respawn_mutant_" .. npc_name)
        end

        -- Conditions for sending news
        if is_mutant_in_spawn_pool and se_obj_outside_spawn_radius(npc, 100) and se_obj_outside_spawn_radius(who, 100) and attacker_name ~= db.actor:character_name() then
            local location_description = dynamic_news_helper.GetPointDescription(who) or "in an unknown location"
            location_description = location_description:gsub("^in ", "")
            
            local phrase_keys = get_phrase_keys("rebound_encounters_encounter_news")

            -- Select a random key and retrieve its translation
            if #phrase_keys > 0 then
                local random_key = phrase_keys[math.random(#phrase_keys)]
                local translated_text = game.translate_string(random_key)
                local random_encounter_news = string.format(translated_text, attacker_name, npc_name, location_description)
                news_manager.send_tip(db.actor, random_encounter_news, nil, nil, 3000)
            end
        end
    end
end

function read_ltx_section(filename,section,field)
	local ini = ini_file(filename)
	local value = ini and ini:r_string_ex(section,field) or "nil"
    return value
end


-- functions for dev purposes only
function on_key_press(key)
    if key == DIK_keys["DIK_I"] and enable_debug then
        --[[shuffle_smart_ids()
        try_to_spawn()
        get_spawnable_squads_report()
        news_manager.send_tip(db.actor, string.format("AVAILABLE SMARTS: %d  Mutant POOL: %d  MAX ACTIVE SPAWNS: %d Active Spanws: %d", count_available_smart_terrains(), #squads_to_spawn, max_active_spawns, #active_spawns), nil,nil, 3000)
        ]]
    end

    if key == DIK_keys["DIK_O"] and enable_debug then
        --[[delete_mutants()
        get_active_spawns_report()
        news_manager.send_tip(db.actor, string.format("AVAILABLE SMARTS: %d  Mutant POOL: %d  MAX ACTIVE SPAWNS: %d Active Spanws: %d", count_available_smart_terrains(), #squads_to_spawn, max_active_spawns, #active_spawns), nil,nil, 3000)
        ]]
    end

    if key == DIK_keys["DIK_P"] and enable_debug then
        delete_mutants()
        get_current_game_values()
        news_manager.send_tip(db.actor, string.format("All active spawns deleted. Saving your game now will make it free from all RE:Spawn mutants. ACTIVE SPAWNS: %d", #active_spawns), nil,nil, 3000)
    end
end

function anomaly_on_before_activate(zone, obj, flags)
    flags.ret_value = true

    if not obj or not zone then
        return
    end
    
    -- Check if the object is a monster.
    if IsMonster(obj) then
        -- If the monster is not alive, set the return value to false.
        if not obj:alive() then
            return flags.ret_value
        end
        
        -- Check if the monster is a spawned mutant.
        for idx, spawn in ipairs(active_spawns) do
            if obj.id == spawn.mutant_id then                
                -- If the spawned mutant is a boss mutant, it's immune to anomalies.
                if spawn.is_boss_mutant then
                    pr("Boss Mutant is immune to anomalies")
                    flags.ret_value = false
                    -- Return immediately, as the anomaly activation is cancelled.
                    return flags.ret_value
                end
            end
        end

        -- If the monster is not a boss mutant, it remains affected by the anomaly.
        return flags.ret_value
    end
    
    -- Check if the object is a bolt; if it is, allow the anomaly activation.
    if obj:clsid() == clsid.obj_bolt then
        flags.ret_value = true
    end
    
    return flags.ret_value
end

-- Debug functions
function get_spawnable_squads_report()
    pr("Current Level: " .. level.name() .. " It is currently day: " .. tostring(is_day()))
    pr("Squads that can be spawned on the current map:")
    local boss_mutant_count = 0
    for _, squad in ipairs(squads_to_spawn) do
        local squad_info = {
            name = squad.sec,
            is_boss_mutant = squad.is_boss_mutant,
            is_night_mutant = squad.is_night_mutant,
            is_predator_mutant = squad.is_predator_mutant
        }
        if squad_info.is_boss_mutant then
            boss_mutant_count = boss_mutant_count + 1
        end
        pr("  - " .. squad_info.name .. ": is_boss_mutant=" .. tostring(squad_info.is_boss_mutant) .. ", is_night_mutant=" .. tostring(squad_info.is_night_mutant) .. ", is_predator_mutant=" .. tostring(squad_info.is_predator_mutant))
    end
    local player_rank = db.actor:character_rank()
    pr("Counts:")
    pr("  - Squads to Spawn: " .. #squads_to_spawn)
    pr("  - Boss Mutants Available: " .. boss_mutant_count)
    pr("  - Max Active Spawns: " .. max_active_spawns)
    pr("  - Active Spawns: " .. #active_spawns)
    pr("  - Player Rank: " .. get_rank_description(player_rank))
    local player_rank_value = get_rank_value(player_rank)
    pr("  - Player Rank Value: " .. tostring(player_rank_value))
end

function get_current_game_values()
    pr("Current Level: " .. level.name() .. "  Day: " .. tostring(is_day()))
    pr("  - Wipe Mutants on Level change: " .. tostring(wipe_mutants_on_level_change))
    pr("  - Day Start: " .. day_start)
    pr("  - Day End: " .. day_end)
    pr("  - Boss Spawn Probability: " .. boss_spawn_probability)
    pr("  - Predator Spawn Probability: " .. predator_spawn_probability)
    pr("  - enable_spawn_reserve: " .. tostring(enable_spawn_reserve))
    pr("  - enable_ignore_smart_population: " ..tostring(enable_ignore_smart_population))
    pr("  - enable_all_maps_spawning: " .. tostring(enable_all_maps_spawning))
    pr("  - enable_boss_is_night_only: " .. tostring(enable_boss_is_night_only))
    pr("  - Enable Debug: " .. tostring(enable_debug))
end

function get_active_spawns_report()
    pr("Current Level: " .. level.name())
    pr("Active Spawns:")
    local active_boss_mutant_count = 0
    for _, spawn in ipairs(active_spawns) do
        local spawn_info = {
            mutant_id = spawn.mutant_id,
            level_name = spawn.level_name,
            sec = spawn.sec,
            is_night_mutant = spawn.is_night_mutant,
            is_boss_mutant = spawn.is_boss_mutant,
            is_predator_mutant = spawn.is_predator_mutant,
            smart_id = spawn.smart_id
        }
        if spawn_info.is_boss_mutant then
            active_boss_mutant_count = active_boss_mutant_count + 1
        end
        pr("  - Mutant ID: " .. spawn_info.mutant_id .. ", Level: " .. spawn_info.level_name .. ", Sec: " .. spawn_info.sec .. ", is_night_mutant=" .. tostring(spawn_info.is_night_mutant) .. ", is_boss_mutant=" .. tostring(spawn_info.is_boss_mutant) .. ", is_predator_mutant=" .. tostring(spawn_info.is_predator_mutant) .. ", Smart ID: " .. spawn_info.smart_id)
    end
end

-- Function to determine rank description based on player_rank value
function get_rank_description(player_rank)
    -- Define rank ranges and descriptions
    local ranks = {
        {max_points = 1499, description = "novice"},
        {max_points = 2499, description = "trainee"},
        {max_points = 5499, description = "experienced"},
        {max_points = 9999, description = "professional"},
        {max_points = 14999, description = "veteran"},
        {max_points = 19999, description = "expert"},
        {max_points = 29999, description = "master"},
        {max_points = math.huge, description = "legend"} -- math.huge for any value beyond 29999
    }

    for _, rank in ipairs(ranks) do
        if player_rank <= rank.max_points then
            return rank.description
        end
    end

    return "unknown rank"
end

-- Function to determine rank point value based on player_rank value
function get_rank_value(player_rank)
    -- Define rank ranges and point values
    local ranks = {
        {max_points = 1499, value = 1},   -- "novice"
        {max_points = 2499, value = 2},   -- "trainee"
        {max_points = 5499, value = 3},   -- "experienced"
        {max_points = 9999, value = 4},   -- "professional"
        {max_points = 14999, value = 5},  -- "veteran"
        {max_points = 19999, value = 6},  -- "expert"
        {max_points = 29999, value = 7},  -- "master"
        {max_points = math.huge, value = 8} -- "legend"
    }

    -- Iterate through the ranks to find the correct value based on player_rank
    for _, rank in ipairs(ranks) do
        if player_rank <= rank.max_points then
            return rank.value
        end
    end

    return 0 -- or nil if you want to handle unknown ranks differently
end

-- Function to retrieve all available phrase keys with a given phrase root
function get_phrase_keys(phrase_root)
    local phrase_keys = {}
    local index = 1
    local phrase_key, translated_phrase

    -- Loop until no more phrases are found for the given phrase root
    while true do
        -- Construct the phrase key by appending the index
        phrase_key = string.format("%s_%d", phrase_root, index)
        
        -- Retrieve the translated phrase
        translated_phrase = game.translate_string(phrase_key)
        
        -- Check if the translation exists by comparing the returned string
        if translated_phrase == phrase_key then
            -- If the returned string matches the key, it means no translation was found
            break
        end
        
        -- Add the phrase key to the table
        table.insert(phrase_keys, phrase_key)
        
        -- Move to the next index
        index = index + 1
    end

    -- Return the table of phrase keys
    return phrase_keys
end

-- Utility function to shuffle a table in-place
    function shuffle_table(tbl)
        for i = #tbl, 2, -1 do
            local j = math.random(1, i)
            tbl[i], tbl[j] = tbl[j], tbl[i]
        end
    end
    
    -- Main function to shuffle smart IDs within each level
    function shuffle_smart_ids()
        for _, smart_ids in pairs(available_smart_terrains) do
            shuffle_table(smart_ids)
        end
    end


-- Helper function to calculate distances from the actor to all smart terrains on the current level
function calculate_smart_distances()
    local distances = {}
    local actor_pos = db.actor:position()
    
    for _, smart_id in ipairs(available_smart_terrains[level.name()]) do
        local smart = alife_object(smart_id)
        if smart then
        local smart_pos = smart.position
        local distance = actor_pos:distance_to(smart_pos) -- Use distance_to for 3D distance
        distances[smart_id] = distance
        end
    end
    
    return distances
    end
    
    
-- Function to get a sorted table of smart IDs on the current level, excluding those within the safe radius
function get_sorted_smart_ids()
    local distances = calculate_smart_distances()
    local sorted_smart_ids = {}

    -- Filter out smarts within the safe radius
    for smart_id, distance in pairs(distances) do
        if distance > safe_radius then  --Check if outside safe radius
        table.insert(sorted_smart_ids, {smart_id = smart_id, distance = distance})
        end
    end
        
    -- Sort the table by distance (ascending, nearest to farthest)
    table.sort(sorted_smart_ids, function(a, b) return a.distance < b.distance end)


    -- Create a new table containing only the smart IDs
    local result = {}
    for i,entry in ipairs(sorted_smart_ids) do
        result[i] = entry.smart_id
    end

    return result
end

-- Initialize the script on game start
function on_game_start()
    RegisterScriptCallback("actor_on_update", actor_on_update)
    RegisterScriptCallback("actor_on_update", is_actor_safe)
    RegisterScriptCallback("monster_on_loot_init", monster_on_loot_init)
    RegisterScriptCallback("monster_on_death_callback", monster_on_death_callback)
    RegisterScriptCallback("server_entity_on_unregister", server_entity_on_unregister)
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("on_before_level_changing", on_before_level_changing)
    RegisterScriptCallback("on_option_change", fetch_values)
    RegisterScriptCallback("GUI_on_hide", actor_sleeping)
    RegisterScriptCallback("GUI_on_show", actor_sleeping)
    RegisterScriptCallback("monster_on_hit_callback", monster_on_hit_callback)
    RegisterScriptCallback("on_key_press", on_key_press)
    RegisterScriptCallback("anomaly_on_before_activate", anomaly_on_before_activate)
end